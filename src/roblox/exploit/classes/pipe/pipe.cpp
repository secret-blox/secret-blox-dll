#include "pipe.h"
#include <roblox/security/obfuscation/string.h>
#include <roblox/miscellaneous/offsets/addresses.h>

std::map<std::string, module::namePipe*> pipeMap = {};

namespace module {
	namePipe::namePipe(std::string pipeName) : pipeName(pipeName) {
		std::string obfuscatedPipe{ obfuscate_str("\\\\.\\pipe\\") };
		this->pipeHandle = CreateNamedPipeA(
			(obfuscatedPipe + pipeName).c_str(),
			PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
			1,
			9999999, 9999999,
			NMPWAIT_USE_DEFAULT_WAIT,
			nullptr);

		
		std::thread(
			[this, obfuscatedPipe, pipeName]() -> void {
				DWORD read{};
				char bufferSize[999999];
				std::string outCome{ "" };

				pipeLoop:
				while (this->pipeHandle != INVALID_HANDLE_VALUE) {
					if (ConnectNamedPipe(this->pipeHandle, nullptr) != FALSE) {
						while (ReadFile(this->pipeHandle, bufferSize, sizeof(bufferSize) - 1, &read, nullptr) != FALSE) {
							bufferSize[read] = '\0';
							outCome += bufferSize;
						}

						try {
							this->callback(outCome);
						}
						catch (std::exception ex) {
							/* idk */
						}

						outCome.clear();
					}

					DisconnectNamedPipe(this->pipeHandle);
				}

				this->pipeHandle = CreateNamedPipeA(
					(obfuscatedPipe + pipeName).c_str(),
					PIPE_ACCESS_DUPLEX,
					PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
					1,
					9999999, 9999999,
					NMPWAIT_USE_DEFAULT_WAIT,
					nullptr);

				goto pipeLoop;
				/*if (pipeMap.find(this->pipeName) != pipeMap.end()) {
					pipeMap.erase(this->pipeName);
				}*/
			}
		).detach();
	}

	auto namePipe::createPipe(std::string pipeName) -> namePipe* {
		/*if (pipeMap.find(pipeName) != pipeMap.end()) {
			return pipeMap[pipeName];
		}*/

		auto pipeClass = new namePipe{ pipeName };
		//pipeMap.insert(std::pair<std::string, namePipe*>{ pipeName, pipeClass });

		return pipeClass;
	}

	auto namePipe::write(std::string data) -> DWORD {
		DWORD bytesWritten = 0;
		
		WriteFile(this->pipeHandle,
			data.c_str(),
			data.size(),
			&bytesWritten,
			NULL);

		return bytesWritten;
	}
}