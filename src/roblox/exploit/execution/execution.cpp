//#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <roblox/exploit/classes/console/console.h>
#include <roblox/miscellaneous/configuration.hpp>
//#include <roblox/exploit/classes/render/render.h>
#include <roblox/exploit/classes/pipe/pipe.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/ldo.h>
#include <utilities/utils/utils.h>
#include <Luau/BytecodeBuilder.h>
#include <Luau/Compiler.h>
#include "execution.h"
#include <lualib.h>
#include <mutex>



//const auto renderer{ module::render::getSingleton() };
module::execution* executionSingleton{ nullptr };
module::scheduler::jobType schedulerRet{ NULL };
auto utilities{ module::utils::getSingleton() };
static std::intptr_t taskDeferRef{ NULL };
//std::mutex mutex;

struct liveThreadRef {
	int unk_0;
	lua_State* state;
	int threadId;
};

struct threadRef {
	liveThreadRef* ref;
	threadRef(lua_State* L) {
		ref = new liveThreadRef;
		ref->state = L;
		lua_pushthread(L);
		ref->threadId = lua_ref(L, -1);
		lua_pop(L, 1);
	}
};

auto __cdecl schedulerHook(std::intptr_t self) -> std::uintptr_t {
	//std::unique_lock<std::mutex> guard{ mutex };
	if (!executionSingleton->empty()) {
		module::schedulerTask task = executionSingleton->top();
		//guard.unlock();

		auto taskScheduler{ module::scheduler::getSingleton() };
		auto console{ module::console::getSingleton() };
		//auto luauBytecode{ module::luauBytecode::getSingleton() };

		auto luaState{ taskScheduler->getLuaState() };


		if (task.isc) {
			try {
				task.func(luaState);
			}
			/*catch (lua_exception& ex) {
				console->writeMode(ex.what(), module::console::error);
			}*/
			catch (std::exception ex) {
				console->writeMode(ex.what(), module::console::error);
			}

			return 0;
		}
		else {
			luaState = lua_newthread(luaState, true);
			luaL_sandboxthread(luaState);

			if (taskDeferRef == NULL) {
				lua_getglobal(luaState, obfuscate_str("task"));
				lua_getfield(luaState, -1, obfuscate_str("defer"));

				lua_clonefunction(luaState, -1);
				taskDeferRef = lua_ref(luaState, -1);

				lua_settop(luaState, 0);
			}


			static std::string startScript{ obfuscate_str("script=Instance.new(\"LocalScript\");\t") };
			const std::string& luaScript{ (startScript + task.script) };
			std::string bytecode{ Luau::compile(luaScript) };
			setIdentity(luaState, 8);

			if (bytecode[0] == 0) {
				std::string err{ bytecode.c_str() + 1 };
				console->writeMode(err, module::console::error);
			}
			else {
#if !EXPLOIT_USE_RVM
				lua_getref(luaState, taskDeferRef);
#endif

				if (luau_load(luaState, utilities->randomString(16).c_str(), bytecode.c_str(), bytecode.size(), 0) == LUA_OK) {
					Closure* currentCl = (Closure*)lua_topointer(luaState, -1);
					Proto* p = currentCl->l.p;

					__int64* ptr = new __int64[11];
					p->userdata = (void*)ptr;
					*reinterpret_cast<std::uintptr_t*>(reinterpret_cast<std::uintptr_t>(p->userdata) + 48) = 8;
					*reinterpret_cast<std::uintptr_t*>(reinterpret_cast<std::uintptr_t>(p->userdata) + 72) = 65343;
#if EXPLOIT_USE_RVM
					if (lua_pcall(luaState, 0, 0, 0) != LUA_OK) {
						console->writeMode(lua_tostring(luaState, -1), module::console::error);
					}
#else
					//reinterpret_cast<int(__cdecl*)(lua_State*)>(rebase(0x23fae5242b0))(luaState);
					if (lua_pcall(luaState, 1, 0, 0) != LUA_OK) {
						console->writeMode(lua_tostring(luaState, -1), module::console::error);
					}
					//executionSingleton->resume(luaState, 0);
#endif
				}
				else {
					console->writeMode(lua_tostring(luaState, -1), module::console::error);
					//renderer->addNotificationTimer(lua_tostring(luaState, -1), 2.5);
				}

				lua_settop(luaState, 0);
			}
		}
	}

	return 0;
}


lua_CFunction oldNamecall = nullptr;
auto moduleNamecall(lua_State* L) -> int {
	//Closure* currentFunc = clvalue(L->base_ci->func);//&(L->base_ci->func->value.gc->cl);

	auto identity = *reinterpret_cast<std::intptr_t*>(reinterpret_cast<std::intptr_t>(L->userdata) + 48);
	auto capability2 = *reinterpret_cast<std::intptr_t*>(reinterpret_cast<std::intptr_t>(L->userdata) + 64);
	auto capability1 = *reinterpret_cast<std::intptr_t*>(reinterpret_cast<std::intptr_t>(L->userdata) + 72);
	//auto protoCap = 0;

	//if (currentFunc->isC == FALSE) {
	//	Proto* p = currentFunc->l.p;
	//	protoCap = 42069;
	//	//if (p->userdata != nullptr)
	//	//	protoCap = *reinterpret_cast<std::intptr_t*>(reinterpret_cast<std::intptr_t>(p->userdata) + 72);
	//}

	module::roblox::stdOut(0, "Identity: %i | Capability1: %i | Capability2: %i", identity, capability1, capability2);

	if (oldNamecall == nullptr)
		return 0;

	return oldNamecall(L);
}

namespace module {
	execution* execution::singleton{ nullptr };
	auto execution::getSingleton() -> execution* {
		if (singleton == nullptr)
			singleton = new execution();

		return singleton;
	};

	auto execution::load() -> void {
		taskDeferRef = 0;

		executionSingleton = this;
		auto taskScheduler{ module::scheduler::getSingleton() };
		schedulerRet = reinterpret_cast<scheduler::jobType>(taskScheduler->jobHook(schedulerHook));

		/*auto th = lua_newthread(taskScheduler->getLuaState(), true);
		
		lua_getglobal(th, obfuscate_str("game"));
		if (lua_getmetatable(th, -1)) {
			lua_getfield(th, -1, obfuscate_str("__namecall"));

			Closure* namecallClosure = (Closure*)lua_topointer(th, -1);
			oldNamecall = namecallClosure->c.f;
			lua_pop(th, 1);

			lua_setreadonly(th, -1, false);
			lua_pushstring(th, obfuscate_str("__namecall"));
			lua_pushcclosurek(th, moduleNamecall, nullptr, 0, NULL);
			lua_rawset(th, -3);
			lua_setreadonly(th, -1, true);

			lua_settop(th, 0);
		}*/

	};

	auto execution::createPipe() -> void {
		if (this->pipeInitialize)
			return;

		this->pipeInitialize = true;

		std::string obfuscatedName{ obfuscate_str(PIPE_NAME) };
		auto pipe{ namePipe::createPipe(obfuscatedName) };

		pipe->callback = [this](std::string luaCode) -> void {
			this->send(luaCode);
		};
	};

	auto execution::send(std::string script, std::string chunk, lua_State* L) -> std::intptr_t {
		//std::unique_lock<std::mutex> guard{ mutex };
		if (L == nullptr) { // push to scheduler
			this->schedulerQueue.push(schedulerTask{ script });
		}
		else {
			const std::string& bytecode = Luau::compile(script);

			if (chunk == "") {
				chunk = utilities->randomString(16).c_str();
			}

			if (luau_load(L, chunk.c_str(), bytecode.c_str(), bytecode.size(), 0) != LUA_OK) {
				std::string err = lua_tostring(L, -1);
				lua_pop(L, 1);

				lua_pushnil(L);
				lua_pushlstring(L, err.c_str(), err.size());
				return 2;
			}
			
			return 1;
		}

		return 0;
	}

	auto execution::send(std::function<void(lua_State* L)> func) -> std::intptr_t {
		//std::unique_lock<std::mutex> guard{ mutex };
		this->schedulerQueue.push(schedulerTask{ func });
		return 0;
	}

	auto execution::empty() -> bool {
		return this->schedulerQueue.empty();
	};

	auto execution::top() -> schedulerTask {
		module::schedulerTask task{ this->schedulerQueue.front() };
		this->schedulerQueue.pop();
		return task;
	};

	auto execution::resume(lua_State* L, std::intptr_t results) -> std::intptr_t {
		auto taskScheduler{ module::scheduler::getSingleton() };
		/*auto scriptContextResume = reinterpret_cast<std::uintptr_t(__cdecl*)(std::uintptr_t scriptContext, uintptr_t * blmProtest, uintptr_t * *liveThRef, int arguments, bool bVal, int blacks)>(rebase(0x23fae475df0));
		
		uintptr_t blmProtest[4];
		liveThreadRef* liveThRef = threadRef{ L }.ref;
		scriptContextResume(taskScheduler->getScriptContext(), blmProtest, (uintptr_t**)(&liveThRef), results, false, 0);*/
		
		// 0x1bee7875df0
		lua_State* th = lua_newthread(L);

		if (taskDeferRef == NULL) {
			lua_getglobal(th, obfuscate_str("task"));
			lua_getfield(th, -1, obfuscate_str("defer"));

			lua_clonefunction(th, -1);
			taskDeferRef = lua_ref(th, -1);

			lua_settop(th, 0);
		}

		lua_getref(th, taskDeferRef);

		lua_pushthread(L);
		lua_xmove(L, th, 1);
		lua_pop(L, 1);

		for (int i = results; i >= 1; i--) {
			lua_pushvalue(L, -i);
			lua_xmove(L, th, 1);
		}

		lua_pcall(th, results + 1, 0, 0);
		lua_settop(th, 0);
		return 0;
	}
}

auto setIdentity(lua_State* L, std::intptr_t identity) -> void { // 96
	std::intptr_t identityObfuscated = 63;
	switch (identity) {
	case 1:
		identityObfuscated = 3;
		break;
	case 2:
		identityObfuscated = 3;
		break;
	case 3:
		identityObfuscated = 3;
		break;
	case 4:
		identityObfuscated = 3;
		break;
	case 5:
		identityObfuscated = 1;
		break;
	case 6:
		identityObfuscated = 11;
		break;
	case 7:
		identityObfuscated = 63;
		break;
	case 8:
		identityObfuscated = 63;
		break;
	case 9:
		identityObfuscated = 12;
		break;
	default:
		identityObfuscated = 12;
		break;
	}

	if (identity > 9) {
		identityObfuscated = 12;
	}
	// 8 = 65343

	//(*((std::intptr_t*)&(identityObfuscated))) = (identityObfuscated & 0x200);//(identityObfuscated | 65280); // 768 65280 (0xff00 | -256)
	identityObfuscated = 63;
	identity = 8;
	__int64* identityPtr = &identity;
	int64_t extraSpace0 = (int64_t)L->userdata;

	//reinterpret_cast<void(__cdecl*)(lua_State*, __int64*, void*)>(rebase(0x26681d722a0))(L, identityPtr, L->userdata);

	int64_t rax_10 = *(int64_t*)(extraSpace0 + 24);
	*(int64_t*)(extraSpace0 + 48) = *(int64_t*)identityPtr;
	*(int64_t*)(extraSpace0 + 64) = identityPtr[1];
	*(int64_t*)(extraSpace0 + 64) = 65343;//*(int64_t*)(rax_10 + 8);
	//*(int64_t*)(extraSpace0 + 72) = 65343; /* maybe */
	//*(int64_t*)(extraSpace0 + 88) = 65343; /* maybe */

	int64_t rax_4 = (identityObfuscated | (65343 & -256));

	*reinterpret_cast<intptr_t*>(*reinterpret_cast<uintptr_t*>(*reinterpret_cast<void**>(reinterpret_cast<uintptr_t>(NtCurrentTeb()) + 88)) + 440) = identity; /* impersonator identity */
	*reinterpret_cast<intptr_t*>(*reinterpret_cast<uintptr_t*>(*reinterpret_cast<void**>(reinterpret_cast<uintptr_t>(NtCurrentTeb()) + 88)) + 456) = identityPtr[1];
	*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::uintptr_t*>(*reinterpret_cast<void**>(reinterpret_cast<std::uintptr_t>(NtCurrentTeb()) + 88)) + 472) = rax_4;


	*(int64_t*)(extraSpace0 + 72) = 65343;

	


	//int off = offsetof(Proto, userdata);
	//*reinterpret_cast<std::uintptr_t*>(reinterpret_cast<std::uintptr_t>(L->userdata) + 48) = identity;
	//*reinterpret_cast<std::intptr_t*>(reinterpret_cast<std::uintptr_t>(L->userdata) + 64) = 65343;//(63 | (65343 & -256)); /* extraspace capability */
	//*reinterpret_cast<std::intptr_t*>(reinterpret_cast<std::uintptr_t>(L->userdata) + 72) = 65343;//(63 | (65343 & -256)); /* extraspace capability */
	//*reinterpret_cast<std::intptr_t*>(reinterpret_cast<std::uintptr_t>(L->userdata) + 63) = 65343;//(63 | (65343 & -256)); /* extraspace capability */
	//*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::intptr_t*>(reinterpret_cast<std::uintptr_t>(L->userdata) + 96) + 240) = 65343;//(63 | (65343 & -256)); /* extraspace capability */


	//*reinterpret_cast<std::uintptr_t*>(*reinterpret_cast<std::uintptr_t*>(*reinterpret_cast<void**>(reinterpret_cast<std::uintptr_t>(NtCurrentTeb()) + 88)) + module::identityImpersonator) = identity;
	//*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::uintptr_t*>(*reinterpret_cast<void**>(reinterpret_cast<std::uintptr_t>(NtCurrentTeb()) + 88)) + 408) = identityPtr[1];
	//*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::uintptr_t*>(*reinterpret_cast<void**>(reinterpret_cast<std::uintptr_t>(NtCurrentTeb()) + 88)) + 424) = identity;

	//
	/*identityObfuscated = (identityObfuscated | -256);
	
	*reinterpret_cast<std::uintptr_t*>(reinterpret_cast<std::uintptr_t>(L->userdata) + 72) = identityObfuscated;
	*reinterpret_cast<std::uintptr_t*>(reinterpret_cast<std::uintptr_t>(L->userdata) + 80) = identityObfuscated;
	*/

	//__int64* identityPtr = &identity;
	//int64_t rax_4 = (EncodeIdentity(arg2) | (0xff00 & -256));
	//int64_t rax_4 = (12 | (0xff00 & -256));
	//*reinterpret_cast<std::intptr_t*>(reinterpret_cast<std::uintptr_t>(L->userdata) + 48) = identity; /* extraspace identity */
	//*reinterpret_cast<std::intptr_t*>(reinterpret_cast<std::uintptr_t>(L->userdata) + 72) = rax_4; /* extraspace capability */

	//*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::uintptr_t*>(*reinterpret_cast<void**>(reinterpret_cast<std::uintptr_t>(NtCurrentTeb()) + 88)) + 392) = identity; /* impersonator identity */
	//*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::uintptr_t*>(*reinterpret_cast<void**>(reinterpret_cast<std::uintptr_t>(NtCurrentTeb()) + 88)) + 408) = identityPtr[1];
	//*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::uintptr_t*>(*reinterpret_cast<void**>(reinterpret_cast<std::uintptr_t>(NtCurrentTeb()) + 88)) + 424) = rax_4;
	return;
}