#include "scheduler.h"
#include <dependencies/luau/vm/src/lstate.h>
#include <utilities/utils/utils.h>
#include <lualib.h>
#include <thread>

const auto utilities{ module::utils::getSingleton() };

namespace module {
	scheduler* scheduler::singleton{ nullptr };
	auto scheduler::getSingleton() -> scheduler* {
		if (singleton == nullptr)
			singleton = new scheduler();

		return singleton;
	};

	scheduler::scheduler() {
		this->taskScheduler = roblox::taskScheduler();

		std::uintptr_t* jobStart{ *reinterpret_cast<std::uintptr_t**>(this->taskScheduler + offsets::schedulerJobStart) };
		std::uintptr_t* jobEnd{ *reinterpret_cast<std::uintptr_t**>(this->taskScheduler + offsets::schedulerJobEnd) };

		while (jobStart != jobEnd) {
			this->jobVector.push_back(*(std::uintptr_t*)(jobStart));
			jobStart += 2;
		}
	};

	auto scheduler::reInitialize() -> void {
		this->taskScheduler = roblox::taskScheduler();
		this->jobVector.clear();

		std::uintptr_t* jobStart{ *reinterpret_cast<std::uintptr_t**>(this->taskScheduler + offsets::schedulerJobStart) };
		std::uintptr_t* jobEnd{ *reinterpret_cast<std::uintptr_t**>(this->taskScheduler + offsets::schedulerJobEnd) };

		while (jobStart != jobEnd) {
			this->jobVector.push_back(*(std::uintptr_t*)(jobStart));
			jobStart += 2;
		}
	};

	auto scheduler::getJobName(std::uintptr_t job) -> std::string {
		return *reinterpret_cast<std::string*>(job + offsets::schedulerJobName);
	};

	auto scheduler::getJob(std::string_view name) -> std::uintptr_t {
		std::uintptr_t jobRet{ NULL };
		std::string oName{ obfuscate_str("WaitingHybridScriptsJob") };

		for (std::uintptr_t job : this->jobVector) {
			if (this->getJobName(job) == name)
				jobRet = job;
		}

		/*if (name == oName) {
			for (std::uintptr_t job : this->jobVector) {
				if (this->getJobName(job) == name) {
					auto datamodel = this->getDataModel(job);
					auto gameId = *reinterpret_cast<std::uintptr_t*>(datamodel + module::datamodelGameId);
					if (gameId != NULL) {
						return job;
					}
				}
			}
		}
		else {
			for (std::uintptr_t job : this->jobVector) {
				if (this->getJobName(job) == name)
					jobRet = job;
			}
		}*/

		return jobRet;
	};

	auto scheduler::jobHook(void* hookFunc) -> std::uintptr_t {
		//lua_State* th = lua_newthread(this->getLuaState(), true);
		lua_CFunction func = (lua_CFunction)hookFunc;
		//luaL_sandboxthread(this->getLuaState());

		std::thread(
			[func]() -> void {
				while (true) {
					try {
						func(nullptr);
					}
					catch (std::exception ex) {

					}

					Sleep(100);
				}
			}
		).detach();

		/*lua_getglobal(th, obfuscate_str("game"));
		lua_getfield(th, -1, obfuscate_str("GetService"));
		lua_pushvalue(th, -2);
		lua_pushstring(th, obfuscate_str("RunService"));
		lua_pcall(th, 2, 1, 0);

		lua_getfield(th, -1, obfuscate_str("RenderStepped"));
		lua_getfield(th, -1, obfuscate_str("Connect"));
		lua_pushvalue(th, -2);
		lua_pushcclosurek(th, (lua_CFunction)hookFunc, obfuscate_str("SchedulerCycle"), 0, nullptr);
		lua_pcall(th, 2, 0, 0);
		lua_settop(th, 0);*/

		return 0;
	};

	auto scheduler::setFps(double fps) -> void {
		*reinterpret_cast<double*>(this->taskScheduler + module::schedulerFps) = 1 / fps;
	}

	auto scheduler::getFps() -> double {
		return (1 / *reinterpret_cast<double*>(this->taskScheduler + module::schedulerFps));
	}

	auto scheduler::getScriptJob() -> std::intptr_t {
		std::string name{ obfuscate_str("WaitingHybridScriptsJob") };
		return this->getJob(name);
	}

	auto scheduler::getScriptContext(std::intptr_t scriptJob) -> std::intptr_t {
		return *reinterpret_cast<std::uintptr_t*>((scriptJob == -1 ? this->getScriptJob() : scriptJob) + offsets::scriptJobScriptContext);
	};

	auto scheduler::getDataModel(std::intptr_t scriptJob) -> std::intptr_t { /* 48 */
		return *reinterpret_cast<std::uintptr_t*>((scriptJob == -1 ? this->getScriptJob() : scriptJob) + offsets::scriptJobDataModel);
	};

	auto scheduler::getLuaState(std::intptr_t context) -> lua_State* {
		uintptr_t script[] = { 0, 0 };
		uintptr_t identity{ 8 };
		return roblox::getState((context == -1 ? this->getScriptContext() : context), &identity, script);
	};

	auto scheduler::getRawDataModel() -> std::uintptr_t { /* Okay I get it I got lazy I admit it I stayed up all night and it was 10 am at the time */
		std::uintptr_t taskSchedulerAddy = roblox::taskScheduler();

		std::uintptr_t jobStart{ *reinterpret_cast<std::uintptr_t*>(taskSchedulerAddy + offsets::schedulerJobStart) };
		std::uintptr_t jobEnd{ *reinterpret_cast<std::uintptr_t*>(taskSchedulerAddy + offsets::schedulerJobEnd) };
		std::uintptr_t JAJA = NULL;

		std::string name{ obfuscate_str("WaitingHybridScriptsJob") };
		while (jobStart != jobEnd) {
			std::uintptr_t job = *(std::uintptr_t*)(jobStart);

			if (this->getJobName(job) == name) {
				JAJA = job;
				auto datamodel = this->getDataModel(job);
				auto gameId = *reinterpret_cast<std::uintptr_t*>(datamodel + module::datamodelGameId);
				if (gameId != NULL) {
					return datamodel;
				}
			}

			jobStart += 8;
		}

		return -1;
	}

	auto scheduler::isLoaded() -> bool {
		return (this->taskScheduler != roblox::taskScheduler());
	}
}